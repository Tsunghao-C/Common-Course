# 42 Common Core Porject - Push_swap

## Objective

## Key concept

## Note

### Different Sorting Methods

| Sorting Method                      | Mechanism                                                                                                                                                | Pros                                                                                                 | Cons                                                                                                                | Estimated Steps for 500 Elements                                                      | NULL |
|-------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|------|
| Merge Sort                          | Divide the stack into two halves, recursively sort each half, and merge the sorted halves.                                                               | Efficient with O(n log n) time complexity. Can handle large datasets well.                           | Requires additional space for auxiliary stacks. Implementation can be complex.                                      | Best Case: O(n log n) ≈ 4500 steps, Worst Case: O(n log n) ≈ 4500 steps               | NULL |
| Insertion Sort                      | Use an auxiliary stack to keep the elements in sorted order by inserting elements from the original stack into the auxiliary stack in the correct order. | Simple to implement. Only requires O(1) additional space.                                            | Inefficient with O(n^2) time complexity for large datasets.                                                         | Best Case: O(n) ≈ 500 steps, Worst Case: O(n^2) ≈ 125,000 steps                       | NULL |
| Selection Sort                      | Repeatedly find the minimum element from the unsorted part of the stack and move it to a sorted auxiliary stack.                                         | Simple to understand and implement.                                                                  | Inefficient with O(n^2) time complexity. Requires additional space for the auxiliary stack.                         | Best Case: O(n^2) ≈ 125,000 steps, Worst Case: O(n^2) ≈ 125,000 steps                 | NULL |
| Bubble Sort                         | Repeatedly swap adjacent elements if they are in the wrong order, using a temporary stack to hold elements during swaps.                                 | Simple to implement.                                                                                 | Very inefficient with O(n^2) time complexity. Requires additional space for temporary stack.                        | Best Case: O(n) ≈ 500 steps, Worst Case: O(n^2) ≈ 125,000 steps                       | NULL |
| Quick Sort                          | Choose a pivot, partition the stack into elements less than and greater than the pivot, and recursively sort the partitions.                             | Efficient with average-case O(n log n) time complexity. Can be implemented in place.                 | Worst-case time complexity is O(n^2). Requires careful implementation to handle stack-based partitioning.           | Best Case: O(n log n) ≈ 4500 steps, Worst Case: O(n^2) ≈ 125,000 steps                | NULL |
| Heap Sort                           | Use a heap data structure to sort the stack, where the stack is transformed into a heap, and elements are extracted in sorted order.                     | Efficient with O(n log n) time complexity.                                                           | Requires additional space for the heap. Implementation is more complex compared to simpler sorting algorithms.      | Best Case: O(n log n) ≈ 4500 steps, Worst Case: O(n log n) ≈ 4500 steps               | NULL |
| Radix Sort                          | Sort the stack by processing individual digits or bits, using auxiliary stacks or queues to group elements.                                              | Efficient with O(nk) time complexity for certain data types (e.g., integers).                        | Limited to sorting specific data types (e.g., integers). Requires additional space for auxiliary structures.        | Best Case: O(nk) ≈ 1000 steps (for k = 2), Worst Case: O(nk) ≈ 1500 steps (for k = 3) | NULL |
| Recursive Sort with Temporary Stack | Use a temporary stack to hold elements while recursively sorting the original stack, inserting elements back in sorted order.                            | Simple to implement. Works well for small stacks.                                                    | Inefficient with O(n^2) time complexity for large datasets. Requires additional space for the temporary stack.      | Best Case: O(n^2) ≈ 125,000 steps, Worst Case: O(n^2) ≈ 125,000 steps                 | NULL |
| Shell Sort                          | Sort elements at a specific interval (gap), reducing the gap size over time, and performing insertion sort for each gap size.                            | More efficient than insertion sort and bubble sort with O(n log n) complexity in some gap sequences. | Performance depends heavily on the gap sequence. Not as efficient as merge, quick, or heap sort for large datasets. | Best Case: O(n log n) ≈ 2500 steps, Worst Case: O(n^1.5) ≈ 12,500 steps               |      |

